.andMatching((Request request) -> {
                try {
                    ObjectMapper objectMapper = new ObjectMapper();
                    JsonNode jsonNode = objectMapper.readTree(request.getBodyAsString());

                    if (jsonNode.has("amount")) {
                        int amount = jsonNode.get("amount").asInt();

                        // Positive amount check
                        if (amount > 0) {
                            return MatchResult.exactMatch();
                        } else {
                            return MatchResult.noMatch();  // Trigger a failure
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return MatchResult.noMatch();  // No match if 'amount' field is missing or invalid
            })






implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        WireMockServer wireMockServer = new WireMockServer(8081);  // Running WireMock on port 8081
        wireMockServer.start();

        // Stub for positive amount -> 200 OK
        wireMockServer.stubFor(post(urlEqualTo("/api/amount-check"))
            .withRequestBody(matchingJsonPath("$.amount", greaterThan(0)))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("{ \"message\": \"Transaction successful\", \"status\": \"SUCCESS\" }"))
        );

        // Stub for negative amount -> 400 Bad Request
        wireMockServer.stubFor(post(urlEqualTo("/api/amount-check"))
            .withRequestBody(matchingJsonPath("$.amount", lessThan(0)))
            .willReturn(aResponse()
                .withStatus(400)
                .withHeader("Content-Type", "application/json")
                .withBody("{ \"message\": \"Transaction failed: Negative amount\", \"status\": \"FAILED\" }"))
        );

        // Optional: Stub for amount equal to 0 -> Custom message
        wireMockServer.stubFor(post(urlEqualTo("/api/amount-check"))
            .withRequestBody(matchingJsonPath("$.amount", equalTo(0)))
            .willReturn(aResponse()
                .withStatus(400)
                .withHeader("Content-Type", "application/json")
                .withBody("{ \"message\": \"Transaction failed: Amount cannot be zero\", \"status\": \"FAILED\" }"))
        );

        System.out.println("WireMock server is running on port 8081...");
    }
}


import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/transaction")
public class TransactionController {

    private final Map<String, String> transactionStatusMap = new HashMap<>();

    // API to create a transaction and make the async call to WireMock
    @PostMapping
    public ResponseEntity<String> createTransaction() {
        String transactionId = UUID.randomUUID().toString();  // Generate transaction ID
        transactionStatusMap.put(transactionId, "IN-PROGRESS");  // Initially, set status to IN-PROGRESS

        // Make a call to WireMock at 8081 to simulate async processing
        // Assuming RestTemplate is used for making the API call
        RestTemplate restTemplate = new RestTemplate();
        String wireMockUrl = "http://localhost:8081/api/async";
        Map<String, String> requestBody = Map.of("transactionId", transactionId);

        ResponseEntity<String> response = restTemplate.postForEntity(wireMockUrl, requestBody, String.class);
        if (response.getStatusCode().is2xxSuccessful()) {
            return ResponseEntity.ok("Transaction initiated with ID: " + transactionId);
        } else {
            return ResponseEntity.status(response.getStatusCode()).body("Failed to initiate transaction");
        }
    }

    // API to update the transaction status after webhook is triggered
    @PostMapping("/status/{transactionId}")
    public ResponseEntity<String> updateTransactionStatus(@PathVariable String transactionId, @RequestBody Map<String, String> body) {
        String newStatus = body.get("status");
        if (transactionStatusMap.containsKey(transactionId)) {
            transactionStatusMap.put(transactionId, newStatus);
            return ResponseEntity.ok("Transaction " + transactionId + " updated to " + newStatus);
        } else {
            return ResponseEntity.status(404).body("Transaction ID not found");
        }
    }

    // Optional: API to check the status of a transaction
    @GetMapping("/{transactionId}")
    public ResponseEntity<String> getTransactionStatus(@PathVariable String transactionId) {
        String status = transactionStatusMap.get(transactionId);
        if (status != null) {
            return ResponseEntity.ok("Status of transaction " + transactionId + " is " + status);
        } else {
            return ResponseEntity.status(404).body("Transaction ID not found");
        }
    }
}





 wireMockServer.stubFor(post(urlPathEqualTo("/api/async"))
            .willReturn(aResponse()
                .withStatus(200)
                .withBody("{\"status\": \"IN-PROGRESS\", \"transactionId\": \"{{jsonPath request.body '$.transactionId'}}\"}")
                .withTransformers("response-template"))  // To use JSON path in the response body
            .withServeEventListener("webhook", webhook()
                .withMethod(POST)
                .withUrl("http://localhost:8080/api/transaction/status/{{jsonPath request.body '$.transactionId'}}")
                .withHeader("Content-Type", "application/json")
                .withBody("{\"status\": \"SUCCESS\"}")
                .withDelay(5000)));






import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  // Use random port for the Spring Boot app
public class WireMockPOCTests {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void testSyncResponseFromWireMock() {
        // Call the WireMock server (on port 8080)
        ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/sync", String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Synchronous response received!", response.getBody());
    }

    @Test
    public void testDelayedResponseFromWireMock() {
        long startTime = System.currentTimeMillis();

        // Call the WireMock server (on port 8080)
        ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/delayed", String.class);

        long elapsedTime = System.currentTimeMillis() - startTime;
        assertTrue(elapsedTime >= 3000);  // Verify 3 seconds delay
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Delayed response received!", response.getBody());
    }

    // Add more tests for async and dynamic responses
}




import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class TestSecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Disable security for testing purposes
        http.csrf().disable()
            .authorizeRequests()
            .anyRequest().permitAll();  // Allow all requests without authentication

        return http.build();
    }

    // You can also define a test UserDetailsService here if needed
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("test")
            .password("test")
            .roles("USER")
            .build();

        return new InMemoryUserDetailsManager(user);
    }
}





package com.example.wiremockpoc;

import com.github.tomakehurst.wiremock.WireMockServer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.hamcrest.Matchers.containsString;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
public class WireMockPOCTests {

    private WireMockServer wireMockServer;

    @Autowired
    private MockMvc mockMvc;

    @BeforeEach
    public void setup() {
        wireMockServer = new WireMockServer(8080); // WireMock runs on port 8080
        wireMockServer.start();
        configureFor("localhost", 8080);
    }

    @AfterEach
    public void tearDown() {
        wireMockServer.stop();
    }

    @Test
    public void testSyncResponse() throws Exception {
        // Mock WireMock response
        wireMockServer.stubFor(get(urlEqualTo("/api/sync"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("Synchronous response received!")));

        mockMvc.perform(get("/api/sync"))
                .andExpect(status().isOk())
                .andExpect(content().string("Synchronous response received!"));
    }

    @Test
    public void testDelayedResponse() throws Exception {
        // Mock WireMock delayed response
        wireMockServer.stubFor(get(urlEqualTo("/api/delayed"))
                .willReturn(aResponse()
                        .withFixedDelay(3000) // 3 seconds delay
                        .withStatus(200)
                        .withBody("Delayed response received!")));

        long startTime = System.currentTimeMillis();

        mockMvc.perform(get("/api/delayed"))
                .andExpect(status().isOk())
                .andExpect(content().string("Delayed response received!"));

        long elapsedTime = System.currentTimeMillis() - startTime;
        assertTrue(elapsedTime >= 3000); // Ensure delay occurred
    }

    @Test
    public void testDynamicResponseTypeA() throws Exception {
        // Mock dynamic response for type A
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("A")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type A response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"A\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type A response\" }"));
    }

    @Test
    public void testDynamicResponseTypeB() throws Exception {
        // Mock dynamic response for type B
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("B")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type B response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"B\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type B response\" }"));
    }

    @Test
    public void testAsyncResponse() throws Exception {
        // Mock initial async response
        wireMockServer.stubFor(post(urlPathEqualTo("/api/async"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("IN-PROGRESS"))
                .withServeEventListener("webhook", webhook()
                        .withMethod(POST)
                        .withUrl("http://localhost:8081/api/transaction/status")
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"transactionId\": \"123\", \"status\": \"SUCCESS\"}")
                        .withDelay(5000)));  // Simulate 5 seconds delay for webhook

        // Step 1: Send the async request and check for IN-PROGRESS
        mockMvc.perform(post("/api/async"))
                .andExpect(status().isOk())
                .andExpect(content().string("IN-PROGRESS"));

        // Optionally, you can simulate the webhook trigger and validate it separately
        // You can mock the webhook endpoint in your application and assert the response.

        // Example webhook response assertion (mocking your webhook handling logic)
        wireMockServer.verify(postRequestedFor(urlEqualTo("/api/transaction/status"))
                .withHeader("Content-Type", equalTo("application/json"))
                .withRequestBody(containsString("\"status\": \"SUCCESS\"")));
    }
}
