package com.example.wiremockpoc;

import com.github.tomakehurst.wiremock.WireMockServer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.hamcrest.Matchers.containsString;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
public class WireMockPOCTests {

    private WireMockServer wireMockServer;

    @Autowired
    private MockMvc mockMvc;

    @BeforeEach
    public void setup() {
        wireMockServer = new WireMockServer(8080); // WireMock runs on port 8080
        wireMockServer.start();
        configureFor("localhost", 8080);
    }

    @AfterEach
    public void tearDown() {
        wireMockServer.stop();
    }

    @Test
    public void testSyncResponse() throws Exception {
        // Mock WireMock response
        wireMockServer.stubFor(get(urlEqualTo("/api/sync"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("Synchronous response received!")));

        mockMvc.perform(get("/api/sync"))
                .andExpect(status().isOk())
                .andExpect(content().string("Synchronous response received!"));
    }

    @Test
    public void testDelayedResponse() throws Exception {
        // Mock WireMock delayed response
        wireMockServer.stubFor(get(urlEqualTo("/api/delayed"))
                .willReturn(aResponse()
                        .withFixedDelay(3000) // 3 seconds delay
                        .withStatus(200)
                        .withBody("Delayed response received!")));

        long startTime = System.currentTimeMillis();

        mockMvc.perform(get("/api/delayed"))
                .andExpect(status().isOk())
                .andExpect(content().string("Delayed response received!"));

        long elapsedTime = System.currentTimeMillis() - startTime;
        assertTrue(elapsedTime >= 3000); // Ensure delay occurred
    }

    @Test
    public void testDynamicResponseTypeA() throws Exception {
        // Mock dynamic response for type A
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("A")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type A response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"A\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type A response\" }"));
    }

    @Test
    public void testDynamicResponseTypeB() throws Exception {
        // Mock dynamic response for type B
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("B")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type B response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"B\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type B response\" }"));
    }

    @Test
    public void testAsyncResponse() throws Exception {
        // Mock initial async response
        wireMockServer.stubFor(post(urlPathEqualTo("/api/async"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("IN-PROGRESS"))
                .withServeEventListener("webhook", webhook()
                        .withMethod(POST)
                        .withUrl("http://localhost:8081/api/transaction/status")
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"transactionId\": \"123\", \"status\": \"SUCCESS\"}")
                        .withDelay(5000)));  // Simulate 5 seconds delay for webhook

        // Step 1: Send the async request and check for IN-PROGRESS
        mockMvc.perform(post("/api/async"))
                .andExpect(status().isOk())
                .andExpect(content().string("IN-PROGRESS"));

        // Optionally, you can simulate the webhook trigger and validate it separately
        // You can mock the webhook endpoint in your application and assert the response.

        // Example webhook response assertion (mocking your webhook handling logic)
        wireMockServer.verify(postRequestedFor(urlEqualTo("/api/transaction/status"))
                .withHeader("Content-Type", equalTo("application/json"))
                .withRequestBody(containsString("\"status\": \"SUCCESS\"")));
    }
}
