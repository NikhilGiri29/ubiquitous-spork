import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  // Use random port for the Spring Boot app
public class WireMockPOCTests {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void testSyncResponseFromWireMock() {
        // Call the WireMock server (on port 8080)
        ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/sync", String.class);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Synchronous response received!", response.getBody());
    }

    @Test
    public void testDelayedResponseFromWireMock() {
        long startTime = System.currentTimeMillis();

        // Call the WireMock server (on port 8080)
        ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/delayed", String.class);

        long elapsedTime = System.currentTimeMillis() - startTime;
        assertTrue(elapsedTime >= 3000);  // Verify 3 seconds delay
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals("Delayed response received!", response.getBody());
    }

    // Add more tests for async and dynamic responses
}




import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class TestSecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Disable security for testing purposes
        http.csrf().disable()
            .authorizeRequests()
            .anyRequest().permitAll();  // Allow all requests without authentication

        return http.build();
    }

    // You can also define a test UserDetailsService here if needed
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("test")
            .password("test")
            .roles("USER")
            .build();

        return new InMemoryUserDetailsManager(user);
    }
}





package com.example.wiremockpoc;

import com.github.tomakehurst.wiremock.WireMockServer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.hamcrest.Matchers.containsString;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
public class WireMockPOCTests {

    private WireMockServer wireMockServer;

    @Autowired
    private MockMvc mockMvc;

    @BeforeEach
    public void setup() {
        wireMockServer = new WireMockServer(8080); // WireMock runs on port 8080
        wireMockServer.start();
        configureFor("localhost", 8080);
    }

    @AfterEach
    public void tearDown() {
        wireMockServer.stop();
    }

    @Test
    public void testSyncResponse() throws Exception {
        // Mock WireMock response
        wireMockServer.stubFor(get(urlEqualTo("/api/sync"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("Synchronous response received!")));

        mockMvc.perform(get("/api/sync"))
                .andExpect(status().isOk())
                .andExpect(content().string("Synchronous response received!"));
    }

    @Test
    public void testDelayedResponse() throws Exception {
        // Mock WireMock delayed response
        wireMockServer.stubFor(get(urlEqualTo("/api/delayed"))
                .willReturn(aResponse()
                        .withFixedDelay(3000) // 3 seconds delay
                        .withStatus(200)
                        .withBody("Delayed response received!")));

        long startTime = System.currentTimeMillis();

        mockMvc.perform(get("/api/delayed"))
                .andExpect(status().isOk())
                .andExpect(content().string("Delayed response received!"));

        long elapsedTime = System.currentTimeMillis() - startTime;
        assertTrue(elapsedTime >= 3000); // Ensure delay occurred
    }

    @Test
    public void testDynamicResponseTypeA() throws Exception {
        // Mock dynamic response for type A
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("A")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type A response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"A\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type A response\" }"));
    }

    @Test
    public void testDynamicResponseTypeB() throws Exception {
        // Mock dynamic response for type B
        wireMockServer.stubFor(post(urlEqualTo("/api/dynamic-response"))
                .withRequestBody(matchingJsonPath("$.type", equalTo("B")))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("{\"response\": \"Type B response\"}")));

        mockMvc.perform(post("/api/dynamic-response")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{ \"type\": \"B\" }"))
                .andExpect(status().isOk())
                .andExpect(content().json("{ \"response\": \"Type B response\" }"));
    }

    @Test
    public void testAsyncResponse() throws Exception {
        // Mock initial async response
        wireMockServer.stubFor(post(urlPathEqualTo("/api/async"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody("IN-PROGRESS"))
                .withServeEventListener("webhook", webhook()
                        .withMethod(POST)
                        .withUrl("http://localhost:8081/api/transaction/status")
                        .withHeader("Content-Type", "application/json")
                        .withBody("{\"transactionId\": \"123\", \"status\": \"SUCCESS\"}")
                        .withDelay(5000)));  // Simulate 5 seconds delay for webhook

        // Step 1: Send the async request and check for IN-PROGRESS
        mockMvc.perform(post("/api/async"))
                .andExpect(status().isOk())
                .andExpect(content().string("IN-PROGRESS"));

        // Optionally, you can simulate the webhook trigger and validate it separately
        // You can mock the webhook endpoint in your application and assert the response.

        // Example webhook response assertion (mocking your webhook handling logic)
        wireMockServer.verify(postRequestedFor(urlEqualTo("/api/transaction/status"))
                .withHeader("Content-Type", equalTo("application/json"))
                .withRequestBody(containsString("\"status\": \"SUCCESS\"")));
    }
}
